{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";AAAA;;;;EAIE;;AAgGF,MAAM,eAAe;IASnB,YAAY,QAAgB;QAPX,UAAK,GAAG,kBAAkB,CAAC;QAC3B,WAAM,GAAG,iBAAiB,CAAC;QAC3B,UAAK,GAAG,UAAU,CAAC;QACnB,gBAAW,GAAG,CAAC,IAAY,EAAE,EAAE,CAAC,IAAI,MAAM,CAAC,UAAU,GAAG,IAAI,GAAG,UAAU,EAAE,KAAK,CAAC,CAAC;QAKjG,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;CACF","sourcesContent":["/*Progettino in TS\nNOTA: in allegato trovate dei file di test: non li cancellate, e fatene una copia di backup prima di eseguire il vostro codice, in modo tale da poter confrontare l'output dei vs file con quelli forniti negli esempi.\n\nNon viene fornito alcun ambiente di test. In fondo sono riportati alcuni casi di test (sui file in allegato).\n*/\n\n/*\nSi deve progettare una classe TS, chiamata FileTransformer, che opera su file di testo: la classe deve leggere il contenuto di un file di testo fornito in input, e offrire le funzionalità di analisi, codifica e decodifica dettagliate di seguito. Tutti i file contengono caratteri UTF-8.\n\nNOTA: se il file non esiste, tutti i metodi richiesti devono restituire -1.\nSUGGERIMENTO: si consiglia di utilizzare espressioni regolari (si faccia riferimento anche ai lucidi mostrati a lezione, e in generale alle RegExp)\n\nIn particolare, la classe deve offrire i seguenti metodi:\n\n1. Il costruttore, che prende come argomento il nome di un file di testo (si assuma che il file, se esiste, si trovi nella stessa cartella in cui è questo programma TS)\n\n2. contaParole(), che restituisce il numero di parole presenti nel file; una parola è sempre non-vuota (in altre parole, fra due separatori validi non c'è una parola vuota di mezzo -- e quindi non va contata). Si considerino quali caratteri separatori di parole: \n  a. qualsiasi \"whitespace\" (incluso lo \\n e \\r)\n  b. i seguenti segni di interpunzione ! ? , . ; : \" '\n\n  Esempi: \n    In <<Tant'è amara>> le parole sono <<Tant>>, <<è>>, <<amara>>\n    In <<com'i' v'intrai, tant'era>> le parole sono <<com>>, <<i>>, <<v>>, <<intrai>>, <<tant>>, <<era>>\n\n3. contaSpazi(), che restituisce il numero di \"whitespace\" presenti nel file, senza considerare \\n e \\r\n\n4. contaRighe(), che restituisce il numero di righe presenti nel file (contando anche le righe vuote)\n\n5. occorrenze(s), dove s è una stringa. Il metodo deve restituire il numero di occorrenze della stringa s nel file. SUGGERIMENTO: si utilizzino opportune strutture dati a supporto, per EVITARE assolutamente di scandire il contenuto del file ad ogni invocazione del metodo\n\n6. cifra(n), dove n è un intero positivo. Il metodo deve creare un nuovo file, avente come nome nomeFile + \"-\" + n + \".cy\" (dove + indica la concatenazione, e nomeFile il nome del file gestito da questa istanza). Il nuovo file deve contenere tutti i caratteri del file gestito da questa istanza \"traslati\" di n posizioni: in particolare, il carattere j-esimo, c_j, viene sostituito con il carattere che si trova n posizioni dopo c_j nella codifica UTF-8, modulo 1024.\nIl metodo deve restituire il numero di caratteri scritti.\n\nAd esempio, se n = 256, il nome del file gestito da questa istanza è \"test.ck\", e il testo contenuto nel file è\n\n\"sto cifrando \n\nquesto Bel testo con una è\"\n\nil file cifrato da creare si chiamerà \"test.ck-256.cy\", e il suo contenuto sarà:\n\nųŴůĠţũŦŲšŮŤůĊĊűŵťųŴůĠłťŬĠŴťųŴůĠţůŮĠŵŮšĠǨ\n\n7. decifra(f), dove f è il nome di un file cifrato con le regole indicate al punto precedente (e quindi avente suffisso \".cy\"), ed n un intero positivo (si assuma che f esista, che il suo nome rispetti le regole indicate al punto precedente, e che f si trovi nella stessa cartella in cui è questo programma TS). Il metodo deve creare un nuovo file, avente come nome f + \".decy\" (dove + indica la concatenazione), contenente la versione decifrata di f.cy, usando come chiave il valore numerico presente nel nome del file e compreso tra \"-\" e \".cy\". In particolare, ogni carattere viene c_j, viene sotituito con il carattere che si trova n posizioni prima di c_j nella codifica UTF-8, modulo 1024.\nIl metodo deve restituire il numero di caratteri scritti.\n\nAd esempio, se il file da decifrare si chiama \"test.ck-256.cy\" e contiene\n\nųŴůĠţũŦŲšŮŤůĊĊűŵťųŴůĠłťŬĠŴťųŴůĠţůŮĠŵŮšĠǨ\n\nil file decifrato da creare si chiamerà \"test.ck-256.cy.decy\", e il suo contenuto sarà:\n\n\"sto cifrando \n\nquesto Bel testo con una è\"\n\n8. comprimi(), che deve creare un nuovo file, avente come nome nomeFile + \".comp\" (dove + indica la concatenazione, e nomeFile il nome del file gestito da questo oggetto), e contenente una forma compressa di nomeFile, implementata come segue: ogni sequenza di caratteri consecutivi uguali nel file viene sostituita dalla lunghezza della sequenza seguita dal carattere.\n\nSi assuma che nel contenuto del file da comprimere (quindi il contenuto di nomeFile) non siano presenti cifre.\n\nAd esempio, se il nome di questo file è \"test.ck\", e il testo contenuto nel file è\n\n\"WWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWB\"\n\nil file compresso da creare si chiamerà \"test.ck.comp\", e il suo contenuto sarà:\n\n\"10WB12W3B20WB\"\n\n9. decomprimi(f) dove f è il nome di un file compresso con le regole indicate al punto precedente, e quindi avente suffisso \".comp\" (si assuma che il file di nome f esista, e che il suo nome e il suo contenuto rispettino le regole indicate al punto precedente). Il metodo deve creare un nuovo file, avente come nome f + \".decomp\" (dove + indica la concatenazione), contenente la versione decompressa di f.cy (si veda il file di esempio allegato).\nIl metodo deve restituire il numero di caratteri scritti.\n*/\n\n\n\n\n/* \nESEMPI (dopo ogni // viene riportato il valore restituito dall'invocazione del metodo)\n\nsia ft un oggetto FileTransformer sul file \"cantoInf1.txt\"\n\nconsole.log(ft.contaParole()); //1004\nconsole.log(ft.contaSpazi()); //924\nconsole.log(ft.contaRighe()); //144\nconsole.log(ft.occorrenze(\"fui\")); //4\nconsole.log(ft.occorrenze(\"sono\")); //0\nconsole.log(ft.cifra(5)); //5149\nconsole.log(ft.decifra(\"cantoInf1.txt-5.cy\")); //5149\nconsole.log(ft.cifra(256)); //5149\nconsole.log(ft.decifra(\"cantoInf1.txt-256.cy\")); //5149\n\nsia ft un oggetto FileTransformer sul file \"testC.txt\";\n\nconsole.log(ft.contaParole()); //2\nconsole.log(ft.contaSpazi()); //10\nconsole.log(ft.contaRighe()); //9\nconsole.log(ft.comprimi()); //37\nconsole.log(ft.decomprimi(\"testC.txt.comp\")); //75\n*/\nimport * as fs from \"fs\";\n\nclass FileTransformer {\n\n  private readonly WORDS = /[^!?,.;:\"'\\s]+/gm;\n  private readonly SPACES = /[^!?,.;:\"'\\s]/gm;\n  private readonly LINES = /[\\n\\r]/gm;\n  private readonly OCCURRENCES = (word: string) => new RegExp(\"\\\\b(\\\\w*\" + word + \"\\\\w*)\\\\b\", \"gmi\");\n\n  private fileName: string;\n\n  constructor(fileName: string) {\n    this.fileName = fileName;\n  }\n}\n"]}